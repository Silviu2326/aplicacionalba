{
  "timestamp": 1750009335232,
  "data": {
    "models": [],
    "controllers": [
      {
        "name": "CursoController",
        "fileName": "curso.controller.js",
        "content": "const cursoService = require('../services/curso.service.js');\nconst { successResponse, errorResponse } = require('../utils/response.util.js');\n\n/**\n * @description Controlador para orquestar las operaciones sobre los cursos.\n * Maneja las solicitudes HTTP, llama a los servicios correspondientes y formatea la respuesta.\n */\nclass CursoController {\n\n  /**\n   * @description Obtiene una lista paginada y filtrada de cursos activos.\n   * @param {object} req - Objeto de solicitud de Express.\n   * @param {object} res - Objeto de respuesta de Express.\n   * @param {function} next - Middleware de Express para el manejo de errores.\n   */\n  async getCursos(req, res, next) {\n    try {\n      const { page = 1, limit = 10, sort, ...filters } = req.query;\n      const options = { page: parseInt(page), limit: parseInt(limit), sort, filters };\n\n      const result = await cursoService.findAllCursos(options);\n\n      const meta = {\n        totalItems: result.total,\n        totalPages: Math.ceil(result.total / options.limit),\n        currentPage: options.page,\n      };\n\n      return successResponse(res, 200, 'Cursos recuperados exitosamente', result.data, meta);\n    } catch (error) {\n      next(error); // Pasa el error al middleware de errores centralizado\n    }\n  }\n\n  /**\n   * @description Obtiene un curso por su ID, incluyendo el progreso del usuario actual.\n   * @param {object} req - Objeto de solicitud de Express.\n   * @param {object} res - Objeto de respuesta de Express.\n   * @param {function} next - Middleware de Express para el manejo de errores.\n   */\n  async getCursoById(req, res, next) {\n    try {\n      const { id } = req.params;\n      // Se asume que el ID del usuario está en req.user (inyectado por un middleware de autenticación)\n      const userId = req.user?.id; \n\n      if (!userId) {\n        return errorResponse(res, 401, 'No autenticado. Se requiere ID de usuario para ver el progreso.');\n      }\n\n      const curso = await cursoService.findCursoByIdWithProgress(id, userId);\n      return successResponse(res, 200, 'Curso recuperado exitosamente', curso);\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * @description Actualiza el estado de completado de una lección para un usuario.\n   * @param {object} req - Objeto de solicitud de Express.\n   * @param {object} res - Objeto de respuesta de Express.\n   * @param {function} next - Middleware de Express para el manejo de errores.\n   */\n  async updateLeccionStatus(req, res, next) {\n    try {\n      const { cursoId, leccionId } = req.params;\n      const { completed } = req.body;\n      const userId = req.user?.id;\n\n      if (typeof completed !== 'boolean') {\n        return errorResponse(res, 400, 'El campo \\\"completed\\\" es requerido y debe ser un booleano.');\n      }\n      if (!userId) {\n        return errorResponse(res, 401, 'No autenticado. Se requiere ID de usuario para actualizar el progreso.');\n      }\n\n      const result = await cursoService.updateLeccionStatus(userId, cursoId, leccionId, completed);\n      return successResponse(res, 200, result.message, { newProgress: result.newProgress });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * @description Crea un nuevo curso con sus lecciones, recursos y foros asociados.\n   * @param {object} req - Objeto de solicitud de Express.\n   * @param {object} res - Objeto de respuesta de Express.\n   * @param {function} next - Middleware de Express para el manejo de errores.\n   */\n  async createCurso(req, res, next) {\n    try {\n        const cursoData = req.body;\n        // Asumimos que el creador es el usuario autenticado\n        cursoData.instructor = req.user?.id;\n        const nuevoCurso = await cursoService.createCurso(cursoData);\n        return successResponse(res, 201, 'Curso creado exitosamente', nuevoCurso);\n    } catch (error) {\n        next(error);\n    }\n  }\n}\n\nmodule.exports = new CursoController();\n",
        "description": "Controlador que actúa como orquestador para la gestión de cursos. Recibe las peticiones HTTP, extrae parámetros y cuerpo, y llama a los métodos del servicio `cursoService` para ejecutar la lógica de negocio. Formatea las respuestas en un formato JSON estandarizado."
      }
    ],
    "routes": [],
    "services": [
      {
        "name": "CursoService",
        "fileName": "curso.service.js",
        "content": "const mongoose = require('mongoose');\nconst Curso = require('../models/curso.model.js');\nconst Leccion = require('../models/leccion.model.js');\nconst ProgresoUsuarioCurso = require('../models/progresoUsuarioCurso.model.js');\nconst Recurso = require('../models/recurso.model.js');\nconst HiloForo = require('../models/hiloForo.model.js');\n// Asumimos un logger y un manejador de errores de API personalizados\nconst logger = require('../utils/logger.util.js'); \nconst ApiError = require('../utils/ApiError.util.js');\n\n/**\n * @description Servicio con la lógica de negocio para la gestión de cursos.\n * Interactúa directamente con los modelos de Mongoose y maneja transacciones.\n */\nclass CursoService {\n\n  /**\n   * @description Busca todos los cursos activos con filtros, paginación y ordenación.\n   * @param {object} options - Opciones de consulta { page, limit, sort, filters }.\n   * @returns {Promise<{data: Array, total: number}>} - Lista de cursos y conteo total.\n   */\n  async findAllCursos(options) {\n    const { page, limit, sort, filters } = options;\n    const query = Curso.findActive(filters); // Usa el método estático para excluir borrados lógicos\n\n    if (sort) {\n      const sortFormatted = sort.split(',').join(' ');\n      query.sort(sortFormatted);\n    }\n\n    const skip = (page - 1) * limit;\n    query.skip(skip).limit(limit);\n\n    // Ejecuta las consultas en paralelo para mayor eficiencia\n    const [data, total] = await Promise.all([\n      query.exec(),\n      Curso.countDocuments(Curso.findActive(filters).getFilter())\n    ]);\n\n    return { data, total };\n  }\n\n  /**\n   * @description Busca un curso por ID y enriquece el resultado con el progreso del usuario.\n   * @param {string} cursoId - ID del curso.\n   * @param {string} userId - ID del usuario.\n   * @returns {Promise<object>} - Objeto del curso enriquecido.\n   */\n  async findCursoByIdWithProgress(cursoId, userId) {\n    logger.info(`Buscando curso ${cursoId} para usuario ${userId}`);\n    const curso = await Curso.findActive({ _id: cursoId })\n      .populate('lecciones')\n      .populate('recursos')\n      .populate({ path: 'hilosForo', populate: { path: 'autor', select: 'nombre' } })\n      .lean(); // .lean() para obtener un objeto JS plano y más rápido\n\n    if (!curso) {\n      throw new ApiError(404, 'Curso no encontrado o inactivo.');\n    }\n\n    const progreso = await ProgresoUsuarioCurso.findOne({ usuario: userId, curso: cursoId }).lean();\n\n    // Inyectar progreso y estado de lecciones\n    curso.progreso = progreso ? progreso.progreso : 0;\n    const leccionesCompletadas = new Set(\n      progreso ? progreso.leccionesCompletadas.map(id => id.toString()) : []\n    );\n\n    curso.lecciones = curso.lecciones.map(leccion => ({\n      ...leccion,\n      completado: leccionesCompletadas.has(leccion._id.toString()),\n    }));\n\n    return curso;\n  }\n\n  /**\n   * @description Actualiza el estado de una lección y recalcula el progreso del curso.\n   * Utiliza una transacción para garantizar la atomicidad de la operación.\n   * @param {string} userId - ID del usuario.\n   * @param {string} cursoId - ID del curso.\n   * @param {string} leccionId - ID de la lección.\n   * @param {boolean} completed - Nuevo estado de completado.\n   * @returns {Promise<{message: string, newProgress: number}>} - Resultado de la operación.\n   */\n  async updateLeccionStatus(userId, cursoId, leccionId, completed) {\n    const session = await mongoose.startSession();\n    session.startTransaction();\n    logger.info(`Iniciando transacción para actualizar lección ${leccionId} a estado ${completed} para usuario ${userId}`);\n\n    try {\n      const curso = await Curso.findById(cursoId).session(session);\n      if (!curso || curso.deletedAt) throw new ApiError(404, 'Curso no encontrado.');\n\n      const leccion = await Leccion.findById(leccionId).session(session);\n      if (!leccion || leccion.curso.toString() !== cursoId) {\n          throw new ApiError(404, 'Lección no encontrada en este curso.');\n      }\n      \n      let progreso = await ProgresoUsuarioCurso.findOne({ usuario: userId, curso: cursoId }).session(session);\n\n      // Si no existe progreso, el usuario empieza el curso. Lo creamos.\n      if (!progreso) {\n        progreso = new ProgresoUsuarioCurso({ usuario: userId, curso: cursoId });\n      }\n\n      progreso.actualizarEstadoLeccion(leccionId, completed);\n      const totalLecciones = await Leccion.countDocuments({ curso: cursoId }).session(session);\n      progreso.calcularYActualizarProgreso(totalLecciones);\n\n      await progreso.save({ session });\n      await session.commitTransaction();\n      logger.info(`Transacción completada exitosamente para usuario ${userId}`);\n\n      return {\n        success: true,\n        message: `Lección marcada como ${completed ? 'completada' : 'pendiente'}`,\n        newProgress: progreso.progreso\n      };\n    } catch (error) {\n      await session.abortTransaction();\n      logger.error('Error en transacción de actualización de lección:', { error });\n      throw error; // Relanza el error para que el controlador lo capture\n    } finally {\n      session.endSession();\n    }\n  }\n\n  /**\n   * @description Crea un curso y sus documentos asociados (lecciones, etc.) en una transacción.\n   * @param {object} data - Datos del curso, incluyendo arrays para lecciones, recursos, etc.\n   * @returns {Promise<object>} - El curso recién creado.\n   */\n  async createCurso(data) {\n    const { lecciones = [], recursos = [], ...cursoData } = data;\n    const session = await mongoose.startSession();\n    session.startTransaction();\n    logger.info('Iniciando transacción para crear nuevo curso');\n\n    try {\n        const nuevoCurso = new Curso(cursoData);\n        await nuevoCurso.save({ session });\n\n        if (lecciones.length > 0) {\n            const leccionesData = lecciones.map(l => ({ ...l, curso: nuevoCurso._id }));\n            await Leccion.insertMany(leccionesData, { session });\n        }\n\n        if (recursos.length > 0) {\n            const recursosData = recursos.map(r => ({ ...r, curso: nuevoCurso._id }));\n            await Recurso.insertMany(recursosData, { session });\n        }\n\n        await session.commitTransaction();\n        logger.info(`Curso ${nuevoCurso._id} creado exitosamente en transacción.`);\n\n        // Retornamos el curso con sus datos populados\n        return this.findCursoByIdWithProgress(nuevoCurso._id, cursoData.instructor);\n\n    } catch (error) {\n        await session.abortTransaction();\n        logger.error('Error en transacción de creación de curso:', { error });\n        // Si es un error de validación de Mongoose, lo pasamos como un ApiError 400\n        if (error.name === 'ValidationError') {\n            throw new ApiError(400, error.message);\n        }\n        throw error;\n    } finally {\n        session.endSession();\n    }\n  }\n}\n\nmodule.exports = new CursoService();",
        "description": "Servicio que encapsula toda la lógica de negocio para los cursos. Interactúa directamente con los modelos de Mongoose, construye consultas complejas con filtros y paginación, y utiliza transacciones para garantizar la integridad de los datos en operaciones de escritura complejas."
      }
    ],
    "middleware": [],
    "config": [],
    "utils": [],
    "tests": []
  },
  "metadata": {
    "promptLength": 8168,
    "options": {
      "type": "controllers",
      "framework": "express",
      "includeDatabase": true,
      "existingModels": [
        {
          "name": "Curso",
          "fileName": "curso.model.js",
          "content": "const mongoose = require('mongoose');\nconst Schema = mongoose.Schema;\n\n/**\n * Esquema del Curso\n * Representa la entidad principal del curso, conteniendo metadatos y referencias\n * a sus componentes (lecciones, recursos, hilos del foro).\n */\nconst CursoSchema = new Schema({\n  titulo: {\n    type: String,\n    required: [true, 'El título del curso es obligatorio.'],\n    trim: true,\n    minlength: [5, 'El título debe tener al menos 5 caracteres.'],\n    maxlength: [150, 'El título no puede exceder los 150 caracteres.']\n  },\n  descripcion: {\n    type: String,\n    required: [true, 'La descripción del curso es obligatoria.'],\n    maxlength: [1000, 'La descripción no puede exceder los 1000 caracteres.']\n  },\n  instructor: {\n    type: Schema.Types.ObjectId,\n    ref: 'Usuario', // Clave foránea al modelo de Usuario\n    required: [true, 'Se requiere un instructor para el curso.']\n  },\n  duracionTotalEstimada: {\n    type: String, // ej. '8 horas', '4 semanas'\n    required: false\n  },\n  lecciones: [{\n    type: Schema.Types.ObjectId,\n    ref: 'Leccion'\n  }],\n  recursos: [{\n    type: Schema.Types.ObjectId,\n    ref: 'Recurso'\n  }],\n  hilosForo: [{\n    type: Schema.Types.ObjectId,\n    ref: 'HiloForo'\n  }],\n  // Campo para soft delete (borrado lógico)\n  deletedAt: {\n    type: Date,\n    default: null\n  }\n}, {\n  // Añade automáticamente createdAt y updatedAt\n  timestamps: true\n});\n\n// --- ÍNDICES ---\n// Índice de texto para búsquedas eficientes en el título y la descripción.\nCursoSchema.index({ titulo: 'text', descripcion: 'text' });\n// Índice para buscar cursos por instructor.\nCursoSchema.index({ instructor: 1 });\n// Índice para filtrar cursos no borrados.\nCursoSchema.index({ deletedAt: 1 });\n\n\n// --- MÉTODOS ESTÁTICOS ---\n// Busca cursos que no han sido borrados lógicamente.\nCursoSchema.statics.findActive = function() {\n  return this.find({ deletedAt: null });\n};\n\n// --- MÉTODOS DE INSTANCIA ---\n// Método para realizar un borrado lógico del curso y su contenido asociado.\nCursoSchema.methods.softDelete = async function() {\n  this.deletedAt = new Date();\n  // Opcional: Propagar el borrado lógico a lecciones, recursos, etc.\n  // await mongoose.model('Leccion').updateMany({ _id: { $in: this.lecciones } }, { $set: { deletedAt: new Date() } });\n  return this.save();\n};\n\nconst Curso = mongoose.model('Curso', CursoSchema);\n\nmodule.exports = Curso;\n",
          "description": "Modelo principal 'Curso'. Contiene la información general del curso y establece relaciones 1-N con Lecciones, Recursos e Hilos del Foro mediante referencias de ObjectId. Incluye validaciones robustas, timestamps, un campo `deletedAt` para borrado lógico (soft-delete), e índices optimizados para búsquedas por texto e instructor. Provee métodos estáticos (`findActive`) y de instancia (`softDelete`) para una gestión avanzada de los datos."
        },
        {
          "name": "Leccion",
          "fileName": "leccion.model.js",
          "content": "const mongoose = require('mongoose');\nconst Schema = mongoose.Schema;\n\n/**\n * Esquema de Lección\n * Define la estructura de una lección individual dentro de un curso.\n */\nconst LeccionSchema = new Schema({\n  curso: {\n    type: Schema.Types.ObjectId,\n    ref: 'Curso',\n    required: true\n  },\n  titulo: {\n    type: String,\n    required: [true, 'El título de la lección es obligatorio.'],\n    trim: true,\n    maxlength: [200, 'El título no puede exceder los 200 caracteres.']\n  },\n  duracion: {\n    type: String, // ej: '15 min'\n    required: [true, 'La duración es obligatoria.']\n  },\n  tipo: {\n    type: String,\n    required: true,\n    enum: {\n      values: ['video', 'lectura', 'practica'],\n      message: 'El tipo de lección {VALUE} no es válido. Valores permitidos: video, lectura, practica.'\n    }\n  },\n  // Contenido condicional basado en el tipo\n  videoUrl: {\n    type: String,\n    validate: [function() { return this.tipo === 'video'; }, 'videoUrl solo es permitido para lecciones de tipo video.']\n  },\n  contenido: {\n    type: String, // Para HTML o Markdown\n    validate: [function() { return this.tipo === 'lectura'; }, 'contenido solo es permitido para lecciones de tipo lectura.']\n  },\n  instrucciones: {\n    type: String, // Para prácticas o ejercicios\n    validate: [function() { return this.tipo === 'practica'; }, 'instrucciones solo es permitido para lecciones de tipo practica.']\n  },\n  orden: {\n    type: Number,\n    default: 0 // Para mantener el orden de las lecciones dentro del curso\n  },\n  deletedAt: {\n    type: Date,\n    default: null\n  }\n}, { timestamps: true });\n\n// --- ÍNDICES ---\n// Índice compuesto para buscar lecciones de un curso y ordenarlas.\nLeccionSchema.index({ curso: 1, orden: 1 });\n\n// --- MIDDLEWARE (HOOKS) ---\n// Hook pre-save para asegurar que solo se guarde el contenido relevante al tipo de lección.\nLeccionSchema.pre('save', function(next) {\n  if (this.isModified('tipo') || this.isNew) {\n    if (this.tipo !== 'video') this.videoUrl = undefined;\n    if (this.tipo !== 'lectura') this.contenido = undefined;\n    if (this.tipo !== 'practica') this.instrucciones = undefined;\n  }\n  next();\n});\n\nconst Leccion = mongoose.model('Leccion', LeccionSchema);\n\nmodule.exports = Leccion;\n",
          "description": "Modelo 'Leccion'. Cada lección pertenece a un 'Curso'. Utiliza un campo `enum` para el 'tipo' y validaciones personalizadas para asegurar que solo se almacene el contenido relevante (videoUrl, contenido, o instrucciones). Un hook `pre('save')` limpia los campos de contenido no aplicables antes de guardar. Incluye un índice compuesto para una recuperación y ordenación eficiente de las lecciones de un curso."
        },
        {
          "name": "ProgresoUsuarioCurso",
          "fileName": "progresoUsuarioCurso.model.js",
          "content": "const mongoose = require('mongoose');\nconst Schema = mongoose.Schema;\n\n/**\n * Esquema de Progreso del Usuario en un Curso\n * Colección de enlace (N-N) entre Usuarios y Cursos.\n * Almacena el progreso individual de un usuario, incluyendo las lecciones completadas.\n */\nconst ProgresoUsuarioCursoSchema = new Schema({\n  usuario: {\n    type: Schema.Types.ObjectId,\n    ref: 'Usuario',\n    required: true\n  },\n  curso: {\n    type: Schema.Types.ObjectId,\n    ref: 'Curso',\n    required: true\n  },\n  leccionesCompletadas: [{\n    type: Schema.Types.ObjectId,\n    ref: 'Leccion'\n  }],\n  progreso: {\n    type: Number,\n    min: 0,\n    max: 100,\n    default: 0\n  }\n}, { timestamps: true });\n\n// --- ÍNDICES ---\n// Índice único compuesto para asegurar que un usuario solo tenga un registro de progreso por curso.\nProgresoUsuarioCursoSchema.index({ usuario: 1, curso: 1 }, { unique: true });\n\n// --- MÉTODOS DE INSTANCIA ---\n/**\n * Actualiza el progreso en porcentaje basado en las lecciones completadas.\n * Este método necesita acceso al número total de lecciones del curso.\n */\nProgresoUsuarioCursoSchema.methods.calcularYActualizarProgreso = async function() {\n  // Populamos el curso para acceder a sus lecciones\n  const doc = await this.populate({ path: 'curso', select: 'lecciones' });\n  const totalLecciones = doc.curso.lecciones.length;\n  \n  if (totalLecciones > 0) {\n    const progresoCalculado = (this.leccionesCompletadas.length / totalLecciones) * 100;\n    this.progreso = Math.round(progresoCalculado);\n  } else {\n    this.progreso = 0;\n  }\n  return this.save(); // Guarda el progreso actualizado\n};\n\n/**\n * Marca o desmarca una lección como completada y recalcula el progreso.\n */\nProgresoUsuarioCursoSchema.methods.actualizarEstadoLeccion = async function(idLeccion, completar = true) {\n  const leccionId = mongoose.Types.ObjectId(idLeccion);\n  const estaCompletada = this.leccionesCompletadas.some(id => id.equals(leccionId));\n\n  if (completar && !estaCompletada) {\n    this.leccionesCompletadas.push(leccionId);\n  } else if (!completar && estaCompletada) {\n    this.leccionesCompletadas.pull(leccionId);\n  }\n  \n  // Se guarda el cambio en lecciones y luego se recalcula\n  await this.save();\n  return this.calcularYActualizarProgreso();\n};\n\n\nconst ProgresoUsuarioCurso = mongoose.model('ProgresoUsuarioCurso', ProgresoUsuarioCursoSchema);\n\nmodule.exports = ProgresoUsuarioCurso;\n",
          "description": "Modelo de enlace 'ProgresoUsuarioCurso'. Es la pieza clave para manejar la relación N-N entre Usuarios y Cursos. Desacopla el estado (`progreso`, `leccionesCompletadas`) de los modelos principales. Usa un índice único compuesto para garantizar la integridad de los datos. Proporciona métodos de instancia avanzados como `calcularYActualizarProgreso` y `actualizarEstadoLeccion` para encapsular la lógica de negocio, haciendo el API más limpio y robusto. Este modelo es esencial para una aplicación multi-usuario."
        },
        {
          "name": "Recurso",
          "fileName": "recurso.model.js",
          "content": "const mongoose = require('mongoose');\nconst Schema = mongoose.Schema;\n\n/**\n * Esquema de Recurso\n * Archivos o enlaces adicionales para un curso (PDFs, ZIPs, etc.).\n */\nconst RecursoSchema = new Schema({\n  curso: {\n    type: Schema.Types.ObjectId,\n    ref: 'Curso',\n    required: true\n  },\n  nombre: {\n    type: String,\n    required: [true, 'El nombre del recurso es obligatorio.'],\n    trim: true\n  },\n  tipo: {\n    type: String,\n    required: [true, 'El tipo de archivo es obligatorio (ej. PDF, ZIP).']\n  },\n  url: {\n    type: String,\n    required: [true, 'La URL del recurso es obligatoria.'],\n    // Una validación de formato de URL simple\n    match: [/^(https?|ftp):\\/\\/[^\\s/$.?#].[^\\s]*$/i, 'Por favor, introduce una URL válida.']\n  },\n  deletedAt: {\n    type: Date,\n    default: null\n  }\n}, { timestamps: true });\n\n// --- ÍNDICES ---\nRecursoSchema.index({ curso: 1 });\n\nconst Recurso = mongoose.model('Recurso', RecursoSchema);\n\nmodule.exports = Recurso;\n",
          "description": "Modelo 'Recurso'. Representa un archivo o enlace descargable asociado a un 'Curso'. Incluye validaciones para los campos requeridos y un validador de expresión regular para el formato de la URL. Tiene una referencia obligatoria al curso al que pertenece y un índice para búsquedas eficientes por curso."
        },
        {
          "name": "HiloForo",
          "fileName": "hiloForo.model.js",
          "content": "const mongoose = require('mongoose');\nconst Schema = mongoose.Schema;\n\n/**\n * Esquema de Hilo del Foro\n * Representa una conversación o pregunta inicial en el foro de un curso.\n */\nconst HiloForoSchema = new Schema({\n  curso: {\n    type: Schema.Types.ObjectId,\n    ref: 'Curso',\n    required: true\n  },\n  autor: {\n    type: Schema.Types.ObjectId,\n    ref: 'Usuario',\n    required: true\n  },\n  titulo: {\n    type: String,\n    required: [true, 'El título del hilo es obligatorio.'],\n    trim: true,\n    minlength: 10\n  },\n  // El contenido/cuerpo del post inicial podría ir aquí\n  contenido: {\n    type: String,\n    required: [true, 'El contenido del hilo es obligatorio.']\n  },\n  // El campo 'fecha' es manejado por timestamps (createdAt)\n  // El campo 'respuestas' podría ser un contador o un array de refs a un modelo 'RespuestaForo'\n  conteoRespuestas: {\n    type: Number,\n    default: 0\n  },\n  deletedAt: {\n    type: Date,\n    default: null\n  }\n}, { timestamps: true });\n\n// --- ÍNDICES ---\nHiloForoSchema.index({ curso: 1, createdAt: -1 }); // Para listar hilos por curso, los más nuevos primero.\nHiloForoSchema.index({ autor: 1 });\n\nconst HiloForo = mongoose.model('HiloForo', HiloForoSchema);\n\nmodule.exports = HiloForo;\n",
          "description": "Modelo 'HiloForo'. Representa un tema de discusión en el foro de un curso. Está vinculado a un 'Curso' y a un 'Usuario' (autor). En lugar de un campo de fecha estático, utiliza `timestamps` para obtener `createdAt`. El conteo de respuestas se maneja con un campo numérico, que sería más eficiente que contar un array en cada consulta. Incluye índices para la visualización común de hilos (por curso y fecha)."
        }
      ],
      "apiFile": "Curso"
    },
    "generatedAt": "2025-06-15T17:42:15.232Z",
    "size": 11814
  }
}
