{
  "timestamp": 1750008957272,
  "data": {
    "models": [
      {
        "name": "Curso",
        "fileName": "curso.model.js",
        "content": "const mongoose = require('mongoose');\n\n/**\n * Esquema para las Lecciones (Subdocumento anidado en Curso)\n * No es un modelo propio, sino una definición de estructura para ser reutilizada.\n */\nconst LeccionSchema = new mongoose.Schema({\n  titulo: {\n    type: String,\n    required: [true, 'El título de la lección es obligatorio.'],\n    trim: true,\n    maxlength: [150, 'El título de la lección no puede exceder los 150 caracteres.']\n  },\n  tiempoPromedio: {\n    type: Number,\n    min: [0, 'El tiempo promedio no puede ser negativo.'],\n    default: 0, // En minutos\n    comment: 'Tiempo promedio de finalización en minutos.'\n  },\n  abandonos: {\n    type: Number,\n    min: [0, 'El número de abandonos no puede ser negativo.'],\n    default: 0\n  },\n  respuestasCorrectas: {\n    type: Number,\n    min: [0, 'El número de respuestas correctas no puede ser negativo.'],\n    default: 0\n  },\n  totalRespuestas: {\n    type: Number,\n    min: [0, 'El total de respuestas no puede ser negativo.'],\n    default: 0,\n    validate: {\n      validator: function(value) {\n        // 'this' se refiere al subdocumento de la lección\n        return value >= this.respuestasCorrectas;\n      },\n      message: 'El total de respuestas no puede ser menor que el número de respuestas correctas.'\n    }\n  }\n}, {\n  // Evitamos la creación de _id para los subdocumentos si no es necesario referenciarlos individualmente.\n  _id: true \n});\n\n/**\n * Esquema principal para el Modelo de Curso\n */\nconst CursoSchema = new mongoose.Schema({\n  titulo: {\n    type: String,\n    required: [true, 'El título del curso es obligatorio.'],\n    trim: true,\n    maxlength: [200, 'El título no puede exceder los 200 caracteres.']\n  },\n  autor: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'User', // Clave foránea al modelo User\n    required: [true, 'El autor es obligatorio.']\n  },\n  // Denormalización del conteo de estudiantes para lecturas rápidas\n  estudiantes: {\n    type: Number,\n    default: 0,\n    min: [0, 'El número de estudiantes no puede ser negativo.']\n  },\n  fechaCreacion: {\n    type: Date,\n    default: Date.now,\n    comment: 'Fecha de publicación o creación lógica del curso.'\n  },\n  lecciones: {\n    type: [LeccionSchema],\n    validate: [v => Array.isArray(v) && v.length > 0, 'El curso debe tener al menos una lección.']\n  },\n  // Campo para soft-delete\n  deletedAt: {\n    type: Date,\n    default: null\n  }\n}, {\n  timestamps: true, // Añade createdAt y updatedAt automáticamente\n  toJSON: { virtuals: true }, // Asegura que los campos virtuales se incluyan en el JSON\n  toObject: { virtuals: true }\n});\n\n// --- ÍNDICES ---\n// Índice de texto para búsquedas eficientes en el título.\nCursoSchema.index({ titulo: 'text' });\n// Índice compuesto para buscar cursos activos de un autor específico y ordenar por fecha.\nCursoSchema.index({ autor: 1, deletedAt: 1, createdAt: -1 });\n\n\n// --- MIDDLEWARE (HOOKS) ---\n// Hook `pre` para cualquier consulta de tipo `find` (findOne, findById, etc.)\n// Filtra automáticamente los documentos que han sido eliminados con soft-delete.\nCursoSchema.pre(/^find/, function(next) {\n  // `this` es el objeto de la consulta (Query)\n  // Solo se aplica si no se especifica explícitamente que se incluyan los eliminados.\n  if (!this.getOptions().withDeleted) {\n    this.where({ deletedAt: null });\n  }\n  next();\n});\n\n\n// --- MÉTODOS ESTÁTICOS (en el Modelo) ---\n/**\n * Busca cursos incluyendo aquellos marcados como eliminados (soft-deleted).\n * @returns {Query} Una consulta de Mongoose.\n */\nCursoSchema.statics.findWithDeleted = function() {\n  return this.find().setOptions({ withDeleted: true });\n};\n\n/**\n * Genera un reporte de estadísticas agregadas para todos los cursos de un autor.\n * @param {mongoose.Types.ObjectId} autorId - El ID del autor.\n * @returns {Promise<Object>} Un objeto con las estadísticas agregadas.\n */\nCursoSchema.statics.generarReportePorAutor = function(autorId) {\n  return this.aggregate([\n    { $match: { autor: autorId, deletedAt: null } },\n    { $unwind: '$lecciones' },\n    { \n      $group: {\n        _id: '$autor',\n        totalCursos: { $addToSet: '$_id' },\n        totalEstudiantes: { $sum: '$estudiantes' },\n        totalAbandonos: { $sum: '$lecciones.abandonos' },\n        promedioRespuestasCorrectas: { $avg: '$lecciones.respuestasCorrectas' }\n      }\n    },\n    {\n      $project: {\n        _id: 0,\n        autor: '$_id',\n        totalCursos: { $size: '$totalCursos' },\n        totalEstudiantes: 1,\n        totalAbandonos: 1,\n        promedioRespuestasCorrectas: { $round: ['$promedioRespuestasCorrectas', 2] }\n      }\n    }\n  ]);\n};\n\n\n// --- MÉTODOS DE INSTANCIA (en el Documento) ---\n/**\n * Realiza un soft-delete del curso, estableciendo la fecha en `deletedAt`.\n * @returns {Promise<Document>} El documento del curso guardado.\n */\nCursoSchema.methods.softDelete = function() {\n  this.deletedAt = new Date();\n  return this.save();\n};\n\n\n// --- CAMPOS VIRTUALES ---\n/**\n * Campo virtual que calcula la tasa de abandono total del curso.\n */\nCursoSchema.virtual('tasaAbandono').get(function() {\n  if (!this.lecciones || this.lecciones.length === 0) return 0;\n\n  const totalAbandonos = this.lecciones.reduce((sum, leccion) => sum + leccion.abandonos, 0);\n  const estudiantesIniciales = this.estudiantes + totalAbandonos;\n\n  if (estudiantesIniciales === 0) return 0;\n  \n  return parseFloat(((totalAbandonos / estudiantesIniciales) * 100).toFixed(2));\n});\n\n\nmodule.exports = mongoose.model('Curso', CursoSchema);\n",
        "description": "Modelo principal 'Curso' que representa las analíticas de un curso. Incluye un subdocumento para 'Lecciones'. Implementa relaciones (ref a User), soft-delete, índices para optimización de búsquedas, validaciones avanzadas, métodos de instancia y estáticos para lógica de negocio, y hooks para filtrar automáticamente los documentos eliminados."
      },
      {
        "name": "User",
        "fileName": "user.model.js",
        "content": "const mongoose = require('mongoose');\nconst bcrypt = require('bcryptjs'); // Ejemplo de dependencia para hashing\n\nconst UserSchema = new mongoose.Schema({\n  nombre: {\n    type: String,\n    required: [true, 'El nombre es obligatorio.'],\n    trim: true\n  },\n  email: {\n    type: String,\n    required: [true, 'El email es obligatorio.'],\n    unique: true,\n    lowercase: true,\n    trim: true,\n    match: [/.+\\@.+\\..+/, 'Por favor, introduce un correo electrónico válido.']\n  },\n  password: {\n    type: String,\n    required: [true, 'La contraseña es obligatoria.'],\n    select: false // No incluir por defecto en las consultas\n  },\n  role: {\n    type: String,\n    enum: ['creador', 'estudiante', 'admin'],\n    default: 'estudiante'\n  }\n}, {\n  timestamps: true\n});\n\n// --- ÍNDICES ---\n// Índice único en el email para búsquedas rápidas y garantizar unicidad.\nUserSchema.index({ email: 1 });\n\n// --- MIDDLEWARE (HOOKS) ---\n// Hook `pre-save` para hashear la contraseña antes de guardar un nuevo usuario\n// o cuando la contraseña es modificada.\nUserSchema.pre('save', async function(next) {\n  // `this` es el documento del usuario\n  if (!this.isModified('password')) return next();\n\n  try {\n    const salt = await bcrypt.genSalt(10);\n    this.password = await bcrypt.hash(this.password, salt);\n    next();\n  } catch (error) {\n    next(error);\n  }\n});\n\n// --- MÉTODOS DE INSTANCIA ---\n/**\n * Compara la contraseña introducida con la contraseña hasheada en la BD.\n * @param {string} candidatePassword - La contraseña a verificar.\n * @returns {Promise<boolean>} True si la contraseña coincide, false en caso contrario.\n */\nUserSchema.methods.comparePassword = function(candidatePassword) {\n  // `this.password` no está disponible aquí porque tiene `select: false`,\n  // por lo que debemos pedirlo explícitamente en la consulta inicial.\n  // ej: User.findOne({ email }).select('+password');\n  return bcrypt.compare(candidatePassword, this.password);\n};\n\nmodule.exports = mongoose.model('User', UserSchema);\n",
        "description": "Modelo 'User' para representar a los autores de los cursos. Este modelo es referenciado desde el modelo 'Curso'. Incluye validaciones robustas para email, enums para roles, un hook pre-save para hashear contraseñas de forma segura, y un método de instancia para la comparación de contraseñas. El campo de contraseña no se devuelve en las consultas por defecto por seguridad."
      }
    ],
    "controllers": [],
    "routes": [],
    "services": [],
    "middleware": [],
    "config": [],
    "utils": [],
    "tests": []
  },
  "metadata": {
    "promptLength": 5138,
    "options": {
      "type": "models",
      "framework": "express",
      "includeDatabase": true,
      "apiFile": "Analytics"
    },
    "generatedAt": "2025-06-15T17:35:57.272Z",
    "size": 8658
  }
}
