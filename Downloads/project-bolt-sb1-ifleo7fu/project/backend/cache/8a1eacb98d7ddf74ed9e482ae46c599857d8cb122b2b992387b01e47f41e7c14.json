{
  "timestamp": 1750009161679,
  "data": {
    "models": [],
    "controllers": [
      {
        "name": "ConfiguracionController",
        "fileName": "configuracion.controller.js",
        "content": "const configuracionService = require('../services/configuracion.service');\nconst { handleServiceError } = require('../utils/error.handler');\nconst { successResponse } = require('../utils/response.handler');\n\n/**\n * @class ConfiguracionController\n * @description Orquestador para las peticiones HTTP relacionadas con la configuración del usuario.\n * No contiene lógica de negocio; su única responsabilidad es gestionar el ciclo de la petición/respuesta,\n * validar la presencia de datos esenciales (como el ID de usuario) y delegar la lógica al service layer.\n */\nclass ConfiguracionController {\n\n  /**\n   * @description Obtiene la configuración global para el usuario autenticado. Llama al servicio que implementa la lógica 'findOrCreate'.\n   * @param {object} req - Objeto de solicitud de Express. Se espera req.user.id del middleware de autenticación.\n   * @param {object} res - Objeto de respuesta de Express.\n   * @param {function} next - Middleware para el manejo de errores.\n   */\n  async getUserConfig(req, res, next) {\n    const logger = req.log;\n    try {\n      const userId = req.user.id;\n      logger.info({ userId }, 'Iniciando obtención de configuración para el usuario.');\n\n      const configuracion = await configuracionService.findOrCreateUserConfig(userId, logger);\n\n      logger.info({ userId, configId: configuracion._id }, 'Configuración obtenida exitosamente.');\n      return successResponse(res, 200, configuracion, { requestId: req.id });\n\n    } catch (error) {\n      logger.error({ error: { message: error.message, stack: error.stack } }, 'Error en ConfiguracionController.getUserConfig');\n      next(error); // Pasa el error al middleware central de errores\n    }\n  }\n\n  /**\n   * @description Actualiza la configuración global del usuario autenticado.\n   * @param {object} req - Objeto de solicitud de Express. Se espera req.user.id y req.body con los datos a actualizar.\n   * @param {object} res - Objeto de respuesta de Express.\n   * @param {function} next - Middleware para el manejo de errores.\n   */\n  async updateUserConfig(req, res, next) {\n    const logger = req.log;\n    try {\n      const userId = req.user.id;\n      const updateData = req.body;\n\n      if (!updateData || Object.keys(updateData).length === 0) {\n        return handleServiceError({ name: 'ValidationError', message: 'El cuerpo de la solicitud no puede estar vacío.' }, res);\n      }\n\n      logger.info({ userId, updateData }, 'Iniciando actualización de configuración para el usuario.');\n\n      const updatedConfig = await configuracionService.updateUserConfig(userId, updateData, logger);\n\n      logger.info({ userId, configId: updatedConfig._id }, 'Configuración actualizada exitosamente.');\n      return successResponse(res, 200, updatedConfig, { requestId: req.id });\n\n    } catch (error) {\n      logger.error({ error: { message: error.message, stack: error.stack } }, 'Error en ConfiguracionController.updateUserConfig');\n      next(error);\n    }\n  }\n\n  /*\n   * NOTA SOBRE PAGINACIÓN/FILTROS/ORDENACIÓN:\n   * Estos endpoints gestionan un único documento de configuración por usuario (relación 1-a-1).\n   * Por lo tanto, las funcionalidades de paginación, filtros y ordenación no son aplicables aquí,\n   * ya que operan sobre listas de documentos.\n   */\n\n}\n\nmodule.exports = new ConfiguracionController();\n",
        "description": "Controlador que actúa como orquestador para las rutas de configuración. Extrae información de la solicitud HTTP (ID de usuario, cuerpo de la solicitud), invoca los métodos del servicio correspondientes y formatea la respuesta estandarizada. Asume la existencia de un middleware de autenticación que adjunta el usuario a `req` y un logger estructurado en `req.log`."
      }
    ],
    "routes": [],
    "services": [
      {
        "name": "ConfiguracionService",
        "fileName": "configuracion.service.js",
        "content": "const mongoose = require('mongoose');\nconst Configuracion = require('../models/configuracion.model.js');\nconst { ServiceError } = require('../utils/error.handler');\n\n/**\n * @class ConfiguracionService\n * @description Contiene la lógica de negocio para gestionar las configuraciones de los usuarios.\n * Interactúa directamente con el modelo Mongoose 'Configuracion' y maneja las operaciones de base de datos.\n */\nclass ConfiguracionService {\n\n  /**\n   * @description Busca la configuración de un usuario. Si no existe, la crea utilizando los valores por defecto del esquema.\n   * Utiliza el método estático 'findOrCreateForUser' del modelo, que encapsula esta lógica.\n   * @param {string} userId - El ID del usuario.\n   * @param {object} logger - Instancia del logger para trazabilidad.\n   * @returns {Promise<object>} El documento de configuración del usuario.\n   * @throws {ServiceError} Si el userId no es válido o si ocurre un error en la base de datos.\n   */\n  async findOrCreateUserConfig(userId, logger) {\n    if (!mongoose.Types.ObjectId.isValid(userId)) {\n      throw new ServiceError(400, 'ID de usuario no válido.');\n    }\n\n    try {\n      logger.info({ userId }, 'Ejecutando Configuracion.findOrCreateForUser.');\n      // El modelo ya excluye los documentos con 'soft-delete' por defecto\n      const [configuracion, created] = await Configuracion.findOrCreateForUser(userId);\n      \n      logger.info({ userId, configId: configuracion._id, created }, 'Operación findOrCreate completada.');\n      return configuracion;\n    } catch (error) {\n      logger.error({ userId, dbError: error.message }, 'Error de base de datos en findOrCreateUserConfig.');\n      throw new ServiceError(500, 'Error al obtener o crear la configuración.', error);\n    }\n  }\n\n  /**\n   * @description Actualiza la configuración de un usuario con los datos proporcionados.\n   * Usa una transacción de Mongoose como buena práctica para garantizar la atomicidad.\n   * @param {string} userId - El ID del usuario.\n   * @param {object} updateData - Objeto con los campos a actualizar.\n   * @param {object} logger - Instancia del logger para trazabilidad.\n   * @returns {Promise<object>} El documento de configuración actualizado.\n   * @throws {ServiceError} Si la configuración no se encuentra, la validación falla o hay un error de base de datos.\n   */\n  async updateUserConfig(userId, updateData, logger) {\n    if (!mongoose.Types.ObjectId.isValid(userId)) {\n      throw new ServiceError(400, 'ID de usuario no válido.');\n    }\n\n    const session = await mongoose.startSession();\n    session.startTransaction();\n    logger.info({ userId }, 'Iniciando transacción para actualizar configuración.');\n\n    try {\n      // NOTA: Para actualizaciones de campos anidados (ej. accesibilidad.modoOscuro),\n      // el cliente debe enviar el objeto anidado completo (ej. { accesibilidad: { modoOscuro: true, ... } })\n      // o usar 'dot notation' en el body (ej. { 'accesibilidad.modoOscuro': true }).\n      // findOneAndUpdate con $set maneja ambos casos.\n\n      const updatedConfig = await Configuracion.findOneAndUpdate(\n        { user: userId }, // El middleware del modelo ya filtra por `deletedAt: null`\n        { $set: updateData },\n        {\n          new: true, // Devuelve el documento modificado\n          runValidators: true, // Aplica las validaciones del esquema en la actualización\n          session // Asocia la operación a la transacción\n        }\n      ).lean(); // .lean() para un objeto JS plano y más rápido\n\n      if (!updatedConfig) {\n        logger.warn({ userId }, 'Intento de actualizar una configuración no existente.');\n        throw new ServiceError(404, 'Configuración no encontrada para el usuario especificado.');\n      }\n\n      await session.commitTransaction();\n      logger.info({ userId, configId: updatedConfig._id }, 'Transacción completada. Configuración actualizada.');\n      return updatedConfig;\n\n    } catch (error) {\n      await session.abortTransaction();\n      logger.error({ userId, dbError: error.message }, 'Transacción abortada. Error al actualizar la configuración.');\n\n      // Re-lanza errores específicos con el código de estado apropiado\n      if (error.name === 'ValidationError') {\n        // Extraer mensajes de error de validación de Mongoose\n        const validationErrors = Object.values(error.errors).map(e => e.message);\n        throw new ServiceError(400, 'Error de validación.', validationErrors);\n      }\n      if (error instanceof ServiceError) {\n        throw error; // Propaga errores de servicio ya manejados (ej. 404)\n      }\n      throw new ServiceError(500, 'Error de base de datos al actualizar la configuración.', error);\n    } finally {\n      session.endSession();\n    }\n  }\n}\n\nmodule.exports = new ConfiguracionService();\n",
        "description": "Servicio que encapsula toda la lógica de negocio para la gestión de configuraciones. Utiliza directamente el modelo Mongoose `Configuracion`, incluyendo su método estático `findOrCreateForUser`. Implementa las operaciones CRUD, validaciones, manejo de transacciones con Mongoose para asegurar la atomicidad y un manejo de errores detallado que se propaga al controlador."
      }
    ],
    "middleware": [],
    "config": [],
    "utils": [],
    "tests": []
  },
  "metadata": {
    "promptLength": 6572,
    "options": {
      "type": "controllers",
      "framework": "express",
      "includeDatabase": true,
      "existingModels": [
        {
          "name": "Configuracion",
          "fileName": "configuracion.model.js",
          "content": "const mongoose = require('mongoose');\nconst { Schema } = mongoose;\n\n// --- Sub-esquemas para mejorar la organización ---\n\nconst AccesibilidadSchema = new Schema({\n  modoOscuro: {\n    type: Boolean,\n    default: false\n  },\n  altoContraste: {\n    type: Boolean,\n    default: false\n  },\n  tamañoFuente: {\n    type: String,\n    enum: ['pequeño', 'normal', 'grande', 'muy-grande'],\n    default: 'normal'\n  },\n  reducirAnimaciones: {\n    type: Boolean,\n    default: false\n  },\n  lecturaAutomatica: {\n    type: Boolean,\n    default: true\n  }\n}, { _id: false }); // _id: false para que no se cree un ObjectId para el subdocumento\n\nconst NotificacionesSchema = new Schema({\n  email: {\n    type: Boolean,\n    default: true\n  },\n  push: {\n    type: Boolean,\n    default: true\n  },\n  frecuencia: {\n    type: String,\n    enum: ['diario', 'semanal', 'mensual', 'nunca'],\n    default: 'diario'\n  }\n}, { _id: false });\n\n// --- Esquema Principal de Configuración ---\n\nconst ConfiguracionSchema = new Schema({\n  // Relación 1-a-1 con el usuario. Clave foránea.\n  usuario: {\n    type: Schema.Types.ObjectId,\n    ref: 'User', // Asume que existe un modelo 'User'\n    required: [true, 'El ID de usuario es obligatorio.'],\n    unique: true, // Garantiza que cada usuario solo tenga un documento de configuración\n  },\n  idioma: {\n    type: String,\n    enum: {\n      values: ['es', 'en', 'pt', 'fr'],\n      message: 'El idioma {VALUE} no es soportado.'\n    },\n    default: 'es',\n    required: true,\n  },\n  profundidad: {\n    type: String,\n    enum: {\n      values: ['basica', 'media', 'avanzada', 'experta'],\n      message: 'El nivel de profundidad {VALUE} no es válido.'\n    },\n    default: 'media',\n    required: true,\n  },\n  ttsVelocidad: {\n    type: Number,\n    min: [0.5, 'La velocidad TTS no puede ser menor a 0.5.'],\n    max: [2.0, 'La velocidad TTS no puede ser mayor a 2.0.'],\n    default: 1.0,\n    required: true,\n  },\n  formatosExportacion: {\n    type: [String],\n    default: ['pdf', 'notion'],\n  },\n  conectores: {\n    type: [String],\n    default: ['notion', 'calendar'],\n  },\n  accesibilidad: {\n    type: AccesibilidadSchema,\n    default: () => ({}) // Función para asegurar que se cree el objeto por defecto\n  },\n  notificaciones: {\n    type: NotificacionesSchema,\n    default: () => ({})\n  },\n  // Campo para Soft-Delete\n  deletedAt: {\n    type: Date,\n    default: null,\n  },\n}, {\n  // Opciones del esquema\n  timestamps: true, // Agrega createdAt y updatedAt automáticamente\n  toJSON: { virtuals: true },\n  toObject: { virtuals: true },\n});\n\n// --- Índices para optimizar consultas ---\n\n// Índice principal para buscar la configuración de un usuario, incluyendo los eliminados lógicamente.\nConfiguracionSchema.index({ usuario: 1, deletedAt: 1 });\n\n// --- Middleware (Hooks) ---\n\n// Hook PRE-SAVE: Lógica de negocio antes de guardar.\nConfiguracionSchema.pre('save', function (next) {\n  // Si las notificaciones por email y push están desactivadas, forzar la frecuencia a 'nunca'.\n  if (this.isModified('notificaciones')) {\n    if (!this.notificaciones.email && !this.notificaciones.push) {\n      this.notificaciones.frecuencia = 'nunca';\n    }\n  }\n  next();\n});\n\n// Hooks PRE-FIND: Implementación de Soft-Delete.\n// Se aplica a todas las operaciones que empiezan con 'find' para excluir documentos eliminados.\nconst excludeDeleted = function (next) {\n  this.where({ deletedAt: null });\n  next();\n};\nConfiguracionSchema.pre('find', excludeDeleted);\nConfiguracionSchema.pre('findOne', excludeDeleted);\nConfiguracionSchema.pre('findOneAndUpdate', excludeDeleted);\nConfiguracionSchema.pre('countDocuments', excludeDeleted);\n\n\n// --- Métodos de Instancia ---\n\n// Método para realizar un soft-delete en un documento específico\nConfiguracionSchema.methods.softDelete = function () {\n  this.deletedAt = new Date();\n  return this.save();\n};\n\n// Método para restaurar un documento eliminado lógicamente\nConfiguracionSchema.methods.restore = function () {\n  this.deletedAt = null;\n  return this.save();\n};\n\n\n// --- Métodos Estáticos ---\n\n// Método para encontrar la configuración de un usuario o crearla si no existe.\nConfiguracionSchema.statics.findOrCreateForUser = async function (userId) {\n  if (!userId) {\n    throw new Error('Se requiere un ID de usuario para buscar o crear la configuración.');\n  }\n  let config = await this.findOne({ usuario: userId });\n\n  if (!config) {\n    config = await this.create({ usuario: userId });\n  }\n\n  return config;\n};\n\n\nconst Configuracion = mongoose.model('Configuracion', ConfiguracionSchema);\n\nmodule.exports = Configuracion;\n",
          "description": "Modelo Mongoose para la configuración global del usuario. Este esquema está vinculado a un modelo 'User' a través de una referencia obligatoria y única, estableciendo una relación uno a uno. Incorpora sub-esquemas para 'accesibilidad' y 'notificaciones', mejorando la estructura. Implementa validaciones robustas (enum, min/max), valores por defecto y timestamps automáticos. Incluye una estrategia de 'soft-delete' a través del campo 'deletedAt' y middleware que excluye automáticamente los documentos eliminados de las consultas. Proporciona un método estático 'findOrCreateForUser' para simplificar la lógica de obtención/creación de configuraciones y métodos de instancia como 'softDelete' y 'restore' para gestionar el ciclo de vida del documento."
        }
      ],
      "apiFile": "Configuracion"
    },
    "generatedAt": "2025-06-15T17:39:21.679Z",
    "size": 9295
  }
}
