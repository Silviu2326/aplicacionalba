{
  "timestamp": 1750009019883,
  "data": {
    "models": [],
    "controllers": [
      {
        "name": "AnalyticsController",
        "fileName": "analytics.controller.js",
        "content": "const analyticsService = require('../services/analytics.service');\n\n// Asumimos un logger y un wrapper de respuesta estandarizados\n// const logger = require('../utils/logger');\n// const { successResponse, errorResponse } = require('../utils/apiResponse');\n\n/**\n * Controlador para obtener una lista de cursos con paginación, filtros y ordenación.\n */\nconst getCursos = async (req, res, next) => {\n  try {\n    // El logger debería incluir un ID de correlación de la solicitud\n    // logger.info({ message: 'Obteniendo lista de cursos', query: req.query, requestId: req.id });\n\n    const result = await analyticsService.listCursos(req.query);\n\n    const response = {\n      data: result.cursos,\n      meta: {\n        page: result.page,\n        limit: result.limit,\n        totalItems: result.totalItems,\n        totalPages: Math.ceil(result.totalItems / result.limit)\n      }\n    };\n\n    res.status(200).json(response);\n  } catch (error) {\n    next(error);\n  }\n};\n\n/**\n * Controlador para crear un nuevo curso.\n */\nconst createCurso = async (req, res, next) => {\n  try {\n    const cursoData = req.body;\n    // El ID del autor se obtendría de un middleware de autenticación\n    const authorId = req.user.id; \n\n    // logger.info({ message: 'Creando nuevo curso', authorId, requestId: req.id });\n\n    const nuevoCurso = await analyticsService.createCurso(cursoData, authorId);\n\n    res.status(201).json({ data: nuevoCurso });\n  } catch (error) {\n    next(error);\n  }\n};\n\n/**\n * Controlador para obtener un curso por su ID.\n */\nconst getCursoById = async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    // logger.info({ message: `Obteniendo curso con ID: ${id}`, requestId: req.id });\n\n    const curso = await analyticsService.getCursoById(id);\n    \n    // El servicio lanzará un error si no se encuentra, que será manejado por el middleware de errores.\n    res.status(200).json({ data: curso });\n  } catch (error) {\n    next(error);\n  }\n};\n\n/**\n * Controlador para actualizar un curso existente.\n */\nconst updateCurso = async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    const updateData = req.body;\n\n    // logger.info({ message: `Actualizando curso con ID: ${id}`, requestId: req.id });\n\n    const cursoActualizado = await analyticsService.updateCurso(id, updateData);\n\n    res.status(200).json({ data: cursoActualizado });\n  } catch (error) {\n    next(error);\n  }\n};\n\n/**\n * Controlador para eliminar (soft-delete) un curso.\n */\nconst deleteCurso = async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    // logger.info({ message: `Eliminando (soft-delete) curso con ID: ${id}`, requestId: req.id });\n\n    await analyticsService.deleteCurso(id);\n\n    res.status(200).json({ data: { message: 'Curso eliminado exitosamente.' } });\n  } catch (error) {\n    next(error);\n  }\n};\n\nmodule.exports = {\n  getCursos,\n  createCurso,\n  getCursoById,\n  updateCurso,\n  deleteCurso\n};\n",
        "description": "Controlador para el endpoint de Analíticas. Orquesta las solicitudes HTTP, delega la lógica de negocio a la capa de servicio y formatea la respuesta final. No interactúa directamente con la base de datos."
      }
    ],
    "routes": [],
    "services": [
      {
        "name": "AnalyticsService",
        "fileName": "analytics.service.js",
        "content": "const mongoose = require('mongoose');\nconst Curso = require('../models/curso.model.js');\nconst User = require('../models/user.model.js');\n\n// Se podrían definir errores personalizados para un mejor manejo en el middleware de errores\nclass NotFoundError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'NotFoundError';\n    this.statusCode = 404;\n  }\n}\n\n/**\n * Obtiene una lista de cursos basada en parámetros de consulta.\n * Soporta paginación, filtros y ordenación.\n * @param {object} queryParams - Parámetros de la URL (page, limit, sort, ...filters).\n * @returns {Promise<object>} Objeto con la lista de cursos y metadatos de paginación.\n */\nconst listCursos = async (queryParams) => {\n  const { page = 1, limit = 10, sort, ...filters } = queryParams;\n\n  const pageNum = parseInt(page, 10);\n  const limitNum = parseInt(limit, 10);\n  const skip = (pageNum - 1) * limitNum;\n\n  // El hook pre-find del modelo se encargará de añadir { isDeleted: false }\n  const query = Curso.find(filters)\n    .populate('autor', 'nombre email') // Poblar autor y seleccionar campos (ocultar contraseña)\n    .sort(sort ? sort.split(',').join(' ') : '-fechaCreacion')\n    .skip(skip)\n    .limit(limitNum);\n\n  const [cursos, totalItems] = await Promise.all([\n    query.exec(),\n    Curso.countDocuments(filters)\n  ]);\n\n  return { cursos, totalItems, page: pageNum, limit: limitNum };\n};\n\n/**\n * Crea un nuevo curso y actualiza el contador del usuario dentro de una transacción.\n * @param {object} cursoData - Datos del curso a crear.\n * @param {string} authorId - ID del autor del curso.\n * @returns {Promise<object>} El documento del curso recién creado.\n */\nconst createCurso = async (cursoData, authorId) => {\n  const session = await mongoose.startSession();\n  session.startTransaction();\n  try {\n    // Validar que el autor exista\n    const autor = await User.findById(authorId).session(session);\n    if (!autor) {\n      throw new NotFoundError(`Usuario autor con ID '${authorId}' no encontrado.`);\n    }\n\n    const nuevoCurso = new Curso({ ...cursoData, autor: authorId });\n    // La validación del esquema de Mongoose se ejecuta automáticamente al guardar\n    await nuevoCurso.save({ session });\n\n    // Actualizar el contador de cursos del usuario (ejemplo de operación en otra colección)\n    await User.findByIdAndUpdate(authorId, { $inc: { cursosCreadosCount: 1 } }, { session });\n\n    await session.commitTransaction();\n    return nuevoCurso;\n  } catch (error) {\n    await session.abortTransaction();\n    // Si es un error de validación de Mongoose, lo relanza para que sea manejado como un 400 Bad Request\n    throw error;\n  } finally {\n    session.endSession();\n  }\n};\n\n/**\n * Obtiene un único curso por su ID.\n * @param {string} cursoId - El ID del curso.\n * @returns {Promise<object>} El documento del curso.\n */\nconst getCursoById = async (cursoId) => {\n  const curso = await Curso.findById(cursoId).populate('autor', 'nombre email');\n  if (!curso) {\n    // El hook pre-find ya filtra los soft-deleted, por lo que si no se encuentra, es un 404 real.\n    throw new NotFoundError(`Curso con ID '${cursoId}' no encontrado.`);\n  }\n  return curso;\n};\n\n/**\n * Actualiza un curso por su ID.\n * @param {string} cursoId - El ID del curso a actualizar.\n * @param {object} updateData - Los campos a actualizar.\n * @returns {Promise<object>} El documento del curso actualizado.\n */\nconst updateCurso = async (cursoId, updateData) => {\n  const cursoActualizado = await Curso.findByIdAndUpdate(cursoId, updateData, {\n    new: true, // Devuelve el documento modificado\n    runValidators: true // Ejecuta las validaciones del esquema en la actualización\n  }).populate('autor', 'nombre email');\n\n  if (!cursoActualizado) {\n    throw new NotFoundError(`Curso con ID '${cursoId}' no encontrado para actualizar.`);\n  }\n  return cursoActualizado;\n};\n\n/**\n * Realiza un soft-delete en un curso.\n * @param {string} cursoId - El ID del curso a eliminar.\n * @returns {Promise<void>}\n */\nconst deleteCurso = async (cursoId) => {\n  // El modelo `Curso` debe tener implementado un método de soft-delete o se hace manualmente.\n  // Asumiendo que los campos son `isDeleted` y `deletedAt`.\n  const result = await Curso.findByIdAndUpdate(cursoId, {\n    isDeleted: true,\n    deletedAt: new Date()\n  });\n\n  if (!result) {\n    throw new NotFoundError(`Curso con ID '${cursoId}' no encontrado para eliminar.`);\n  }\n};\n\nmodule.exports = {\n  listCursos,\n  createCurso,\n  getCursoById,\n  updateCurso,\n  deleteCurso\n};\n",
        "description": "Servicio de Analíticas que contiene la lógica de negocio. Interactúa con los modelos de Mongoose para realizar operaciones CRUD, gestiona transacciones para escrituras atómicas y aplica la lógica de paginación y filtrado. Lanza errores específicos para ser manejados por la capa superior."
      }
    ],
    "middleware": [],
    "config": [],
    "utils": [],
    "tests": []
  },
  "metadata": {
    "promptLength": 6567,
    "options": {
      "type": "controllers",
      "framework": "express",
      "includeDatabase": true,
      "existingModels": [
        {
          "name": "Curso",
          "fileName": "curso.model.js",
          "content": "const mongoose = require('mongoose');\n\n/**\n * Esquema para las Lecciones (Subdocumento anidado en Curso)\n * No es un modelo propio, sino una definición de estructura para ser reutilizada.\n */\nconst LeccionSchema = new mongoose.Schema({\n  titulo: {\n    type: String,\n    required: [true, 'El título de la lección es obligatorio.'],\n    trim: true,\n    maxlength: [150, 'El título de la lección no puede exceder los 150 caracteres.']\n  },\n  tiempoPromedio: {\n    type: Number,\n    min: [0, 'El tiempo promedio no puede ser negativo.'],\n    default: 0, // En minutos\n    comment: 'Tiempo promedio de finalización en minutos.'\n  },\n  abandonos: {\n    type: Number,\n    min: [0, 'El número de abandonos no puede ser negativo.'],\n    default: 0\n  },\n  respuestasCorrectas: {\n    type: Number,\n    min: [0, 'El número de respuestas correctas no puede ser negativo.'],\n    default: 0\n  },\n  totalRespuestas: {\n    type: Number,\n    min: [0, 'El total de respuestas no puede ser negativo.'],\n    default: 0,\n    validate: {\n      validator: function(value) {\n        // 'this' se refiere al subdocumento de la lección\n        return value >= this.respuestasCorrectas;\n      },\n      message: 'El total de respuestas no puede ser menor que el número de respuestas correctas.'\n    }\n  }\n}, {\n  // Evitamos la creación de _id para los subdocumentos si no es necesario referenciarlos individualmente.\n  _id: true \n});\n\n/**\n * Esquema principal para el Modelo de Curso\n */\nconst CursoSchema = new mongoose.Schema({\n  titulo: {\n    type: String,\n    required: [true, 'El título del curso es obligatorio.'],\n    trim: true,\n    maxlength: [200, 'El título no puede exceder los 200 caracteres.']\n  },\n  autor: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'User', // Clave foránea al modelo User\n    required: [true, 'El autor es obligatorio.']\n  },\n  // Denormalización del conteo de estudiantes para lecturas rápidas\n  estudiantes: {\n    type: Number,\n    default: 0,\n    min: [0, 'El número de estudiantes no puede ser negativo.']\n  },\n  fechaCreacion: {\n    type: Date,\n    default: Date.now,\n    comment: 'Fecha de publicación o creación lógica del curso.'\n  },\n  lecciones: {\n    type: [LeccionSchema],\n    validate: [v => Array.isArray(v) && v.length > 0, 'El curso debe tener al menos una lección.']\n  },\n  // Campo para soft-delete\n  deletedAt: {\n    type: Date,\n    default: null\n  }\n}, {\n  timestamps: true, // Añade createdAt y updatedAt automáticamente\n  toJSON: { virtuals: true }, // Asegura que los campos virtuales se incluyan en el JSON\n  toObject: { virtuals: true }\n});\n\n// --- ÍNDICES ---\n// Índice de texto para búsquedas eficientes en el título.\nCursoSchema.index({ titulo: 'text' });\n// Índice compuesto para buscar cursos activos de un autor específico y ordenar por fecha.\nCursoSchema.index({ autor: 1, deletedAt: 1, createdAt: -1 });\n\n\n// --- MIDDLEWARE (HOOKS) ---\n// Hook `pre` para cualquier consulta de tipo `find` (findOne, findById, etc.)\n// Filtra automáticamente los documentos que han sido eliminados con soft-delete.\nCursoSchema.pre(/^find/, function(next) {\n  // `this` es el objeto de la consulta (Query)\n  // Solo se aplica si no se especifica explícitamente que se incluyan los eliminados.\n  if (!this.getOptions().withDeleted) {\n    this.where({ deletedAt: null });\n  }\n  next();\n});\n\n\n// --- MÉTODOS ESTÁTICOS (en el Modelo) ---\n/**\n * Busca cursos incluyendo aquellos marcados como eliminados (soft-deleted).\n * @returns {Query} Una consulta de Mongoose.\n */\nCursoSchema.statics.findWithDeleted = function() {\n  return this.find().setOptions({ withDeleted: true });\n};\n\n/**\n * Genera un reporte de estadísticas agregadas para todos los cursos de un autor.\n * @param {mongoose.Types.ObjectId} autorId - El ID del autor.\n * @returns {Promise<Object>} Un objeto con las estadísticas agregadas.\n */\nCursoSchema.statics.generarReportePorAutor = function(autorId) {\n  return this.aggregate([\n    { $match: { autor: autorId, deletedAt: null } },\n    { $unwind: '$lecciones' },\n    { \n      $group: {\n        _id: '$autor',\n        totalCursos: { $addToSet: '$_id' },\n        totalEstudiantes: { $sum: '$estudiantes' },\n        totalAbandonos: { $sum: '$lecciones.abandonos' },\n        promedioRespuestasCorrectas: { $avg: '$lecciones.respuestasCorrectas' }\n      }\n    },\n    {\n      $project: {\n        _id: 0,\n        autor: '$_id',\n        totalCursos: { $size: '$totalCursos' },\n        totalEstudiantes: 1,\n        totalAbandonos: 1,\n        promedioRespuestasCorrectas: { $round: ['$promedioRespuestasCorrectas', 2] }\n      }\n    }\n  ]);\n};\n\n\n// --- MÉTODOS DE INSTANCIA (en el Documento) ---\n/**\n * Realiza un soft-delete del curso, estableciendo la fecha en `deletedAt`.\n * @returns {Promise<Document>} El documento del curso guardado.\n */\nCursoSchema.methods.softDelete = function() {\n  this.deletedAt = new Date();\n  return this.save();\n};\n\n\n// --- CAMPOS VIRTUALES ---\n/**\n * Campo virtual que calcula la tasa de abandono total del curso.\n */\nCursoSchema.virtual('tasaAbandono').get(function() {\n  if (!this.lecciones || this.lecciones.length === 0) return 0;\n\n  const totalAbandonos = this.lecciones.reduce((sum, leccion) => sum + leccion.abandonos, 0);\n  const estudiantesIniciales = this.estudiantes + totalAbandonos;\n\n  if (estudiantesIniciales === 0) return 0;\n  \n  return parseFloat(((totalAbandonos / estudiantesIniciales) * 100).toFixed(2));\n});\n\n\nmodule.exports = mongoose.model('Curso', CursoSchema);\n",
          "description": "Modelo principal 'Curso' que representa las analíticas de un curso. Incluye un subdocumento para 'Lecciones'. Implementa relaciones (ref a User), soft-delete, índices para optimización de búsquedas, validaciones avanzadas, métodos de instancia y estáticos para lógica de negocio, y hooks para filtrar automáticamente los documentos eliminados."
        },
        {
          "name": "User",
          "fileName": "user.model.js",
          "content": "const mongoose = require('mongoose');\nconst bcrypt = require('bcryptjs'); // Ejemplo de dependencia para hashing\n\nconst UserSchema = new mongoose.Schema({\n  nombre: {\n    type: String,\n    required: [true, 'El nombre es obligatorio.'],\n    trim: true\n  },\n  email: {\n    type: String,\n    required: [true, 'El email es obligatorio.'],\n    unique: true,\n    lowercase: true,\n    trim: true,\n    match: [/.+\\@.+\\..+/, 'Por favor, introduce un correo electrónico válido.']\n  },\n  password: {\n    type: String,\n    required: [true, 'La contraseña es obligatoria.'],\n    select: false // No incluir por defecto en las consultas\n  },\n  role: {\n    type: String,\n    enum: ['creador', 'estudiante', 'admin'],\n    default: 'estudiante'\n  }\n}, {\n  timestamps: true\n});\n\n// --- ÍNDICES ---\n// Índice único en el email para búsquedas rápidas y garantizar unicidad.\nUserSchema.index({ email: 1 });\n\n// --- MIDDLEWARE (HOOKS) ---\n// Hook `pre-save` para hashear la contraseña antes de guardar un nuevo usuario\n// o cuando la contraseña es modificada.\nUserSchema.pre('save', async function(next) {\n  // `this` es el documento del usuario\n  if (!this.isModified('password')) return next();\n\n  try {\n    const salt = await bcrypt.genSalt(10);\n    this.password = await bcrypt.hash(this.password, salt);\n    next();\n  } catch (error) {\n    next(error);\n  }\n});\n\n// --- MÉTODOS DE INSTANCIA ---\n/**\n * Compara la contraseña introducida con la contraseña hasheada en la BD.\n * @param {string} candidatePassword - La contraseña a verificar.\n * @returns {Promise<boolean>} True si la contraseña coincide, false en caso contrario.\n */\nUserSchema.methods.comparePassword = function(candidatePassword) {\n  // `this.password` no está disponible aquí porque tiene `select: false`,\n  // por lo que debemos pedirlo explícitamente en la consulta inicial.\n  // ej: User.findOne({ email }).select('+password');\n  return bcrypt.compare(candidatePassword, this.password);\n};\n\nmodule.exports = mongoose.model('User', UserSchema);\n",
          "description": "Modelo 'User' para representar a los autores de los cursos. Este modelo es referenciado desde el modelo 'Curso'. Incluye validaciones robustas para email, enums para roles, un hook pre-save para hashear contraseñas de forma segura, y un método de instancia para la comparación de contraseñas. El campo de contraseña no se devuelve en las consultas por defecto por seguridad."
        }
      ],
      "apiFile": "Analytics"
    },
    "generatedAt": "2025-06-15T17:36:59.883Z",
    "size": 8447
  }
}
