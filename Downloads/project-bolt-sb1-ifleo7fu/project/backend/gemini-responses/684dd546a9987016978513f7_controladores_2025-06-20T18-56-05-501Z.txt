Claro, aquí tienes el análisis y la generación de la estructura de `CONTROLLERS` para Express.js, basándome en el archivo proporcionado y siguiendo las mejores prácticas.

### Análisis del Archivo de Origen

El archivo "Configuracion" simula dos operaciones de API del lado del cliente (`localStorage`) para gestionar la configuración de un usuario:

1.  **`getConfiguracionGlobal`**: Obtiene la configuración. Si no existe, crea y devuelve una configuración por defecto. Esto se traduce en un endpoint `GET` que busca la configuración de un usuario en la base de datos y, si no la encuentra, crea una nueva con valores predeterminados.
2.  **`guardarConfiguracionGlobal`**: Actualiza la configuración existente con nuevos datos. Realiza validaciones antes de guardar. Esto se traduce en un endpoint `PATCH` (o `PUT`) que valida los datos del `body` de la petición y actualiza el documento correspondiente en la base de datos. `PATCH` es más adecuado ya que se envían actualizaciones parciales.

En un entorno de backend con Express.js, `localStorage` se reemplaza por una base de datos (como MongoDB o PostgreSQL), y la identificación del usuario se obtiene a través de un middleware de autenticación (por ejemplo, a partir de un token JWT en `req.user.id`).

A continuación se genera el código del controlador correspondiente.

### Respuesta en Formato JSON

```json
{
  "controllers": [
    {
      "name": "ConfiguracionController",
      "fileName": "configuracionController.js",
      "content": "const Configuracion = require('../models/configuracionModel'); // Se asume un modelo de Mongoose\n\n/**\n * @desc    Obtiene la configuración global del usuario autenticado.\n * @route   GET /api/configuracion\n * @access  Privado (requiere autenticación)\n * @summary Reemplaza la lógica de 'getConfiguracionGlobal' del archivo original.\n *          Busca la configuración en la base de datos asociada al usuario.\n *          Si no existe, crea una configuración por defecto para ese usuario.\n */\nconst getConfiguracion = async (req, res) => {\n  try {\n    // El ID del usuario se obtiene del middleware de autenticación (ej: req.user.id)\n    // que se ejecuta antes que este controlador.\n    const userId = req.user.id;\n\n    let configuracion = await Configuracion.findOne({ userId });\n\n    // Si no existe configuración para el usuario, se crea una por defecto.\n    // El modelo de Mongoose debe tener definidos los valores por defecto.\n    if (!configuracion) {\n      configuracion = await Configuracion.create({ userId });\n      return res.status(201).json({\n        exito: true,\n        origen: 'default_created',\n        configuracion,\n      });\n    }\n\n    // Si la configuración ya existía, se devuelve con un estado 200 OK.\n    res.status(200).json({\n      exito: true,\n      origen: 'database',\n      configuracion,\n    });\n\n  } catch (error) {\n    console.error('Error al obtener la configuración:', error);\n    res.status(500).json({\n      error: true,\n      mensaje: 'Error del servidor al obtener la configuración global.',\n      codigo: 'GET_CONFIG_ERROR',\n      detalles: error.message,\n    });\n  }\n};\n\n/**\n * @desc    Actualiza la configuración global del usuario autenticado.\n * @route   PATCH /api/configuracion\n * @access  Privado (requiere autenticación)\n * @summary Reemplaza la lógica de 'guardarConfiguracionGlobal'.\n *          Valida los datos de entrada y actualiza el documento en la BD.\n *          El uso de PATCH es ideal para actualizaciones parciales.\n */\nconst updateConfiguracion = async (req, res) => {\n  const data = req.body;\n\n  // 1. Validación de Datos de Entrada\n  if (!data || Object.keys(data).length === 0) {\n    return res.status(400).json({\n      error: true,\n      mensaje: 'No se proporcionaron datos para actualizar.',\n      codigo: 'INVALID_DATA',\n    });\n  }\n\n  // Validaciones específicas replicadas del código original.\n  const erroresValidacion = [];\n  if (data.idioma && !['es', 'en', 'pt', 'fr'].includes(data.idioma)) {\n    erroresValidacion.push('Idioma no válido. Valores permitidos: es, en, pt, fr.');\n  }\n  if (data.profundidad && !['basica', 'media', 'avanzada', 'experta'].includes(data.profundidad)) {\n    erroresValidacion.push('Profundidad no válida. Valores permitidos: basica, media, avanzada, experta.');\n  }\n  if (data.ttsVelocidad && (data.ttsVelocidad < 0.5 || data.ttsVelocidad > 2.0)) {\n    erroresValidacion.push('Velocidad TTS fuera de rango (debe ser entre 0.5 y 2.0).');\n  }\n\n  if (erroresValidacion.length > 0) {\n    return res.status(400).json({\n      error: true,\n      mensaje: 'Errores de validación en los datos proporcionados.',\n      codigo: 'VALIDATION_ERROR',\n      errores: erroresValidacion,\n    });\n  }\n\n  try {\n    // 2. Lógica de Negocio: Actualización en la Base de Datos\n    const userId = req.user.id;\n\n    // Preparamos los datos a actualizar, incluyendo la fecha para mantener un registro.\n    const updateData = {\n      ...data,\n      fechaActualizacion: new Date(),\n    };\n\n    // Usamos findOneAndUpdate para buscar por userId y actualizar.\n    // 'upsert: true' crea el documento si no existe (robusto).\n    // 'new: true' devuelve el documento ya modificado.\n    // 'runValidators: true' ejecuta las validaciones definidas en el Schema de Mongoose.\n    const configuracionActualizada = await Configuracion.findOneAndUpdate(\n      { userId },\n      { $set: updateData },\n      { new: true, upsert: true, runValidators: true }\n    );\n\n    // 3. Respuesta HTTP Exitosa\n    res.status(200).json({\n      exito: true,\n      mensaje: 'Configuración guardada exitosamente.',\n      configuracion: configuracionActualizada,\n    });\n\n  } catch (error) {\n    console.error('Error al guardar la configuración:', error);\n    // Manejo de errores de validación de Mongoose, si se usan en el modelo.\n    if (error.name === 'ValidationError') {\n      return res.status(400).json({\n        error: true,\n        mensaje: 'Error de validación en la base de datos.',\n        codigo: 'DB_VALIDATION_ERROR',\n        detalles: error.message\n      });\n    }\n\n    res.status(500).json({\n      error: true,\n      mensaje: 'Error del servidor al guardar la configuración.',\n      codigo: 'SAVE_CONFIG_ERROR',\n      detalles: error.message,\n    });\n  }\n};\n\nmodule.exports = {\n  getConfiguracion,\n  updateConfiguracion,\n};\n",
      "description": "Controlador para gestionar la configuración global de un usuario. Incluye funciones para obtener y actualizar la configuración, con validación de datos, manejo de errores y lógica de negocio para interactuar con la base de datos. Asume que un middleware de autenticación provee el ID del usuario en `req.user.id`."
    }
  ]
}
```