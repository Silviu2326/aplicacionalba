Claro, aquí tienes el análisis y la generación de la estructura de **CONTROLLERS** para Express.js, basada en el archivo de API "Integraciones" proporcionado.

Se ha creado un único controlador que gestiona todas las operaciones lógicas y de negocio para las integraciones, siguiendo las mejores prácticas y las instrucciones específicas.

```json
{
  "controllers": [
    {
      "name": "IntegracionController",
      "fileName": "integracionController.js",
      "content": "/*\n * ==================================================================\n * | CONTROLLER - GESTIÓN DE INTEGRACIONES                        |\n * ==================================================================\n * \n * Responsabilidades:\n * - Orquestar la lógica de negocio para las integraciones externas.\n * - Validar los datos de entrada de las solicitudes (requests).\n * - Invocar los servicios o modelos correspondientes para acceder a los datos.\n * - Manejar errores de forma centralizada y responder con códigos HTTP apropiados.\n * - Formatear las respuestas (responses) que se envían al cliente.\n */\n\n// En una aplicación real, estas funciones estarían en un archivo separado \n// (ej: /services/integracionService.js) y se conectarían a una base de datos.\n// Para este ejercicio, simulamos el servicio aquí mismo.\nconst IntegracionService = require('../services/integracionService');\n\n/**\n * @description Obtiene la lista completa de integraciones disponibles.\n * @route GET /api/integraciones\n * @access Privado\n */\nconst getIntegraciones = async (req, res, next) => {\n  try {\n    // Llama al servicio para obtener todas las integraciones\n    const integraciones = await IntegracionService.findAll();\n    \n    res.status(200).json({\n      exito: true,\n      cantidad: integraciones.length,\n      datos: integraciones,\n    });\n  } catch (error) {\n    // Pasa el error al middleware de manejo de errores de Express\n    console.error('Error al obtener integraciones:', error);\n    next(error);\n  }\n};\n\n/**\n * @description Obtiene una integración específica por su ID.\n * @route GET /api/integraciones/:id\n * @access Privado\n */\nconst getIntegracionById = async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    const integracion = await IntegracionService.findById(id);\n\n    // Validación: Si no se encuentra la integración, devolver 404\n    if (!integracion) {\n      const error = new Error('Integración no encontrada');\n      error.statusCode = 404;\n      return next(error);\n    }\n\n    res.status(200).json({\n      exito: true,\n      datos: integracion,\n    });\n  } catch (error) {\n    console.error(`Error al obtener la integración ${req.params.id}:`, error);\n    next(error);\n  }\n};\n\n/**\n * @description Activa o conecta una integración.\n * @route POST /api/integraciones/:id/conectar\n * @access Privado\n */\nconst conectarIntegracion = async (req, res, next) => {\n  try {\n    const { id } = req.params;\n    // En un caso real, el body podría traer tokens de OAuth, etc.\n    const { configuracionInicial } = req.body;\n\n    const integracion = await IntegracionService.findById(id);\n\n    if (!integracion) {\n      const error = new Error('Integración no encontrada');\n      error.statusCode = 404;\n      return next(error);\n    }\n\n    if (integracion.estado === 'conectado') {\n        const error = new Error('La integración ya se encuentra conectada');\n        error.statusCode = 409; // 409 Conflict\n        return next(error);\n    }\n\n    // Lógica de conexión (simulada)\n    const datosActualizados = {\n      estado: 'conectado',\n      ultimaConexion: new Date().toISOString(),\n      // La configuración podría venir del body o ser una por defecto\n      configuracion: configuracionInicial || integracion.configuracion || {},\n      permisos: ['leer', 'escribir'], // Permisos simulados al conectar\n    };\n\n    const integracionActualizada = await IntegracionService.update(id, datosActualizados);\n\n    res.status(200).json({\n      exito: true,\n      mensaje: `Integración '${integracion.nombre}' conectada exitosamente.`,\n      datos: integracionActualizada,\n    });\n  } catch (error) {\n    console.error(`Error al conectar la integración ${req.params.id}:`, error);\n    next(error);\n  }\n};\n\n/**\n * @description Desconecta una integración activa.\n * @route POST /api/integraciones/:id/desconectar\n * @access Privado\n */\nconst desconectarIntegracion = async (req, res, next) => {\n    try {\n        const { id } = req.params;\n        const integracion = await IntegracionService.findById(id);\n\n        if (!integracion) {\n            const error = new Error('Integración no encontrada');\n            error.statusCode = 404;\n            return next(error);\n        }\n\n        if (integracion.estado === 'desconectado') {\n            const error = new Error('La integración ya se encuentra desconectada');\n            error.statusCode = 400; // Bad Request\n            return next(error);\n        }\n\n        // Lógica de desconexión\n        const datosActualizados = {\n            estado: 'desconectado',\n            ultimaConexion: null,\n            configuracion: null,\n            permisos: [],\n        };\n\n        const integracionActualizada = await IntegracionService.update(id, datosActualizados);\n\n        res.status(200).json({\n            exito: true,\n            mensaje: `Integración '${integracion.nombre}' desconectada.`,\n            datos: integracionActualizada,\n        });\n    } catch (error) {\n        console.error(`Error al desconectar la integración ${req.params.id}:`, error);\n        next(error);\n    }\n};\n\n/**\n * @description Prueba la conexión de una integración activa.\n * @route POST /api/integraciones/:id/probar\n * @access Privado\n */\nconst probarConexion = async (req, res, next) => {\n    try {\n        const { id } = req.params;\n        const integracion = await IntegracionService.findById(id);\n\n        if (!integracion) {\n            const error = new Error('Integración no encontrada');\n            error.statusCode = 404;\n            return next(error);\n        }\n\n        if (integracion.estado !== 'conectado') {\n            const error = new Error('Solo se pueden probar integraciones conectadas');\n            error.statusCode = 400; // Bad Request\n            return next(error);\n        }\n\n        // Simulación de una llamada de prueba a la API externa\n        await new Promise(resolve => setTimeout(resolve, 500));\n\n        res.status(200).json({\n            exito: true,\n            mensaje: `La conexión con '${integracion.nombre}' funciona correctamente.`,\n        });\n\n    } catch (error) {\n        console.error(`Error al probar la integración ${req.params.id}:`, error);\n        next(error);\n    }\n};\n\n/**\n * @description Sincroniza datos con una integración activa.\n * @route POST /api/integraciones/:id/sincronizar\n * @access Privado\n */\nconst sincronizarDatos = async (req, res, next) => {\n    try {\n        const { id } = req.params;\n        const integracion = await IntegracionService.findById(id);\n\n        if (!integracion) {\n            const error = new Error('Integración no encontrada');\n            error.statusCode = 404;\n            return next(error);\n        }\n\n        if (integracion.estado !== 'conectado') {\n            const error = new Error('La integración debe estar conectada para sincronizar.');\n            error.statusCode = 400;\n            return next(error);\n        }\n\n        // Validación de permisos\n        if (!integracion.acciones.includes('sincronizar')) {\n            const error = new Error('Esta integración no soporta la acción de sincronizar.');\n            error.statusCode = 403; // Forbidden\n            return next(error);\n        }\n\n        // Simulación de un proceso de sincronización que toma tiempo\n        console.log(`[SYNC] Iniciando sincronización con ${integracion.nombre}...`);\n        await new Promise(resolve => setTimeout(resolve, 1500));\n        console.log(`[SYNC] Sincronización con ${integracion.nombre} completada.`);\n        \n        // Actualizamos la fecha de última conexión/sincronización\n        const datosActualizados = { ultimaConexion: new Date().toISOString() };\n        await IntegracionService.update(id, datosActualizados);\n\n        res.status(200).json({\n            exito: true,\n            mensaje: `Datos sincronizados con '${integracion.nombre}' exitosamente.`,\n            ultimaSincronizacion: datosActualizados.ultimaConexion,\n        });\n\n    } catch (error) {\n        console.error(`Error al sincronizar con la integración ${req.params.id}:`, error);\n        next(error);\n    }\n}\n\nmodule.exports = {\n  getIntegraciones,\n  getIntegracionById,\n  conectarIntegracion,\n  desconectarIntegracion,\n  probarConexion,\n  sincronizarDatos,\n};",
      "description": "Controlador para gestionar todas las operaciones relacionadas con las integraciones externas. Incluye funciones para listar, obtener, conectar, desconectar, probar y sincronizar conectores, aplicando lógica de negocio, validación de datos y manejo de errores."
    }
  ]
}
```