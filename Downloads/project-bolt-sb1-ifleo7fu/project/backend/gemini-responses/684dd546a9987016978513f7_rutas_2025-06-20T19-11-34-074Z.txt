Claro, aquí tienes el análisis del archivo y la generación de la estructura de rutas para Express.js, siguiendo todas tus especificaciones.

### Análisis del Archivo de API

El archivo describe una API para la "Gestión de integraciones". Del contenido y los comentarios, se pueden inferir los siguientes endpoints necesarios:

1.  `GET /api/integraciones`: Para obtener la lista completa de conectores disponibles. El archivo ya define esta función.
2.  `GET /api/integraciones/:id`: Para obtener los detalles de una integración específica usando su `id` (ej. 'notion', 'slack').
3.  `PUT /api/integraciones/:id`: Para actualizar una integración. Esto es ideal para cambiar su estado (`conectado`/`desconectado`) y para guardar su `configuracion`. Es más RESTful que tener endpoints separados para `activar` y `desactivar`.
4.  `POST /api/integraciones/:id/probar`: Para ejecutar una acción específica como "probar la conexión". Como es una acción y no una operación CRUD estándar, se utiliza `POST` sobre un sub-recurso de acción.
5.  `POST /api/integraciones/:id/sincronizar`: Similar al anterior, para iniciar una acción de "sincronización".

Basado en este análisis, se genera el siguiente archivo de rutas.

### Resultado en Formato JSON

```json
{
  "routes": [
    {
      "name": "IntegracionesRoutes",
      "fileName": "integraciones.routes.js",
      "content": "const { Router } = require('express');\nconst { check, param } = require('express-validator');\n\n// --- Importaciones (Asumidas) ---\n// Se asume la existencia de controladores que contienen la lógica de negocio.\nconst {\n  getIntegraciones,\n  getIntegracionById,\n  actualizarConfiguracionIntegracion,\n  probarConexionIntegracion,\n  sincronizarIntegracion\n} = require('../controllers/integraciones.controller'); // La ruta al controlador es un ejemplo\n\n// Se asume la existencia de middlewares personalizados.\nconst { validarCampos } = require('../middlewares/validar-campos'); // Middleware que revisa los resultados de express-validator\nconst { validarIdIntegracion } = require('../middlewares/validar-integracion'); // Middleware que verifica si la integración existe\n// const { validarJWT } = require('../middlewares/validar-jwt'); // Middleware de autenticación (ejemplo)\n\n// Inicialización del router de Express\nconst router = Router();\n\n// --- Definición de Rutas para /api/integraciones ---\n\n/**\n * @route   GET /api/integraciones\n * @desc    Obtener todas las integraciones disponibles, su estado y permisos.\n * @access  Privado (requiere autenticación, ej. validarJWT)\n * @returns {JSON} Retorna un arreglo de objetos de integración.\n * @errors  Manejados por el controlador y el middleware de errores central.\n */\nrouter.get('/', [/* validarJWT */], getIntegraciones);\n\n/**\n * @route   GET /api/integraciones/:id\n * @desc    Obtener los detalles de una integración específica por su ID.\n * @access  Privado\n * @returns {JSON} Retorna el objeto de la integración solicitada.\n * @http    200 - OK, 404 - Not Found.\n */\nrouter.get('/:id',\n  [\n    // validarJWT, // Middleware de autenticación\n    param('id', 'El ID de la integración es inválido.').isString().notEmpty(),\n    validarCampos, // Revisa las validaciones anteriores\n    validarIdIntegracion // Verifica que el ID exista en la base de datos o mock\n  ],\n  getIntegracionById\n);\n\n/**\n * @route   PUT /api/integraciones/:id\n * @desc    Actualiza la configuración y/o el estado de una integración (conectar/desconectar).\n * @access  Privado\n * @body    { estado?: 'conectado'|'desconectado', configuracion?: object }\n * @returns {JSON} Retorna el objeto de la integración actualizada.\n * @http    200 - OK, 400 - Bad Request, 404 - Not Found.\n */\nrouter.put('/:id',\n  [\n    // validarJWT,\n    param('id', 'El ID de la integración es inválido.').isString().notEmpty(),\n    check('estado', 'El estado debe ser \"conectado\" o \"desconectado\".').optional().isIn(['conectado', 'desconectado']),\n    check('configuracion', 'La configuración debe ser un objeto o null.').optional({ nullable: true }).isObject(),\n    validarCampos,\n    validarIdIntegracion\n  ],\n  actualizarConfiguracionIntegracion\n);\n\n/**\n * @route   POST /api/integraciones/:id/probar\n * @desc    Ejecuta una prueba de conexión para una integración específica.\n *          Esta es una ruta de ACCIÓN, por eso se usa POST.\n * @access  Privado\n * @returns {JSON} Retorna un mensaje de éxito o fracaso de la prueba.\n * @http    200 - OK, 400 - Bad Request, 404 - Not Found, 503 - Service Unavailable (si la prueba falla).\n */\nrouter.post('/:id/probar',\n  [\n    // validarJWT,\n    param('id', 'El ID de la integración es inválido.').isString().notEmpty(),\n    validarCampos,\n    validarIdIntegracion\n  ],\n  probarConexionIntegracion\n);\n\n/**\n * @route   POST /api/integraciones/:id/sincronizar\n * @desc    Inicia un proceso de sincronización de datos para una integración.\n *          Esta es una ruta de ACCIÓN.\n * @access  Privado\n * @returns {JSON} Retorna un mensaje indicando el inicio de la sincronización.\n * @http    202 - Accepted (la acción se ha iniciado), 404 - Not Found, 409 - Conflict (si ya está sincronizando).\n */\nrouter.post('/:id/sincronizar',\n  [\n    // validarJWT,\n    param('id', 'El ID de la integración es inválido.').isString().notEmpty(),\n    validarCampos,\n    validarIdIntegracion\n  ],\n  sincronizarIntegracion\n);\n\n/*\n * --- Manejo de Errores Async/Await ---\n * Cada controlador asíncrono debe envolver su lógica en un bloque try/catch.\n * En el bloque catch, se debe llamar a `next(error)` para pasar el control\n * al middleware de manejo de errores centralizado de Express (definido en app.js),\n * el cual se encargará de formatear y enviar una respuesta de error 500.\n * Ejemplo de un controlador:\n * \n * export const miControlador = async (req, res, next) => {\n *   try {\n *     const data = await servicioAsincrono();\n *     res.status(200).json({ exito: true, data });\n *   } catch (error) {\n *     next(error); // Delegar al manejador de errores central.\n *   }\n * };\n */\n\nmodule.exports = router;\n",
      "description": "Este archivo define las rutas de la API para gestionar las integraciones externas. Incluye endpoints para listar, ver detalles, actualizar configuración (conectar/desconectar), probar y sincronizar conectores, aplicando validaciones de datos y siguiendo patrones RESTful."
    }
  ]
}
```